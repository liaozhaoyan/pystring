---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- Outstanding Contributor: achengli
--- DateTime: 2022/12/8 10:37 AM
---

local pystring = {}
local sub = string.sub
local gsub = string.gsub
local match = string.match
local lower = string.lower
local upper = string.upper
local format = string.format
local tostring = tostring
local error = error
local ipairs = ipairs

local require = require
local cpystring = require("cpystring")

local c_count = cpystring.count
local c_find = cpystring.find
local c_rfind = cpystring.rfind
local c_replace = cpystring.replace
local c_rreplace = cpystring.rreplace
local c_startswith = cpystring.startswith
local c_endswith = cpystring.endswith
local c_shift = cpystring.shift
local c_swapcase = cpystring.swapcase
local c_split = cpystring.split
local c_rsplit = cpystring.rsplit
local c_center = cpystring.center
local c_ljust = cpystring.ljust
local c_rjust = cpystring.rjust
local c_reverse_list = cpystring.reverse_list
local c_join = cpystring.join
local c_partition = cpystring.partition
local c_rpartition = cpystring.rpartition
local c_lstrip = cpystring.lstrip
local c_rstrip = cpystring.rstrip
local c_strip = cpystring.strip
local c_map_format = cpystring.map_format


--- Rotates the characters of 's' 'n' positions circulary.
--- --
--- @param s string
--- @param n integer
--- @return string
function pystring.shift(s, n)  -- positive for right, negative for left
    return c_shift(s, n)
end

--- True if the string has only lowercase characters, false if not.
--- --
--- @param s string
--- @return boolean
function pystring.islower(s)
    local matched = match(s, "^[%l%s%p]+$")
    return matched and true or false
end

--- True if the string has only uppercase characters, false if not.
--- --
--- @param s string
--- @return boolean
function pystring.isupper(s)
    local matched = match(s, "^[%u%s%p]+$")
    return matched and true or false
end

--- If the string has only digits it returns true, otherwise it will be 
--- false.
--- --
--- @param s string
--- @return boolean
function pystring.isdigit(s)
    local matched = match(s, "^%d+$")
    return matched and true or false
end

--- If the string is an integer expression it returns true, otherwise false.
--- --
--- @param s string
--- @return boolean
function pystring.isinteger(s)
    local matched = match(s, "^[%-%+]?%d+$")
    return matched and true or false
end

--- If the string is an hexadecimal expression, the function returns true, 
--- otherwise it returns false.
--- --
--- @param s string
--- @return boolean
function pystring.ishex(s)
    local matched = match(s, "^%x+$")
    return matched and true or false
end

--- If the string is a combination of alfanumeric characters, the function 
--- returns true, otherwise it returns false.
--- --
--- @param s string
--- @return boolean
function pystring.isalnum(s)
    local matched = match(s, "^%w+$")
    return matched and true or false
end

--- If the string is a title expression, the function  returns true, otherwise
--- it returns false.
--- --
--- @param s string
--- @return boolean
function pystring.istitle(s)
    local matched = match(s, "^%u%l*$")
    return matched and true or false
end

--- If the string has a float expression, the function will return true, in other
--- case it will be false.
--- --
--- @param s string
--- @return boolean
function pystring.isfloat(s)
    local re = "^[%-%+]?%d*%.%d+$"
    return match(s, re) ~= nil
end

--- Lua string.lower wrapper
--- --
--- @param s string
--- @return string
function pystring.lower(s)
    return lower(s)
end

--- Lua string.lower wrapper
--- --
--- @param s string
--- @return string
function pystring.casefold(s)
    return lower(s)
end

--- Lua string.upper wrapper
--- --
--- @param s string
--- @return string
function pystring.upper(s)
    return upper(s)
end

--- Set to upper case the lower case letters and vice versa.
--- --
--- @param s string
--- @return string
function pystring.swapcase(s)
    return c_swapcase(s)
end

--- Capitalize `s` word.
--- --
--- @param s string
--- @return string
function pystring.capitalize(s)
    if #s < 1 then
        return s
    end
    local s1 = sub(s, 1, 1)
    local s2 = sub(s, 2)
    return format("%s%s", upper(s1), s2)
end

local concat = table.concat
local rep = string.rep
--- Convert the given `s` string in a table of substrings
--- delimited by `delimiter`. The maximum number of substrings is
--- defined by `n` which is MaxInteger by default.
--- --
--- @param s string
--- @param delimiter? string
--- @param n? integer # Default MaxInteger
function pystring.split(s, delimiter, n)
    return c_split(s, delimiter, n)
end

--- Divide s by `del` delimiter returning the left side,
--- the delimiter and the right side.
--- --
--- @param s string
--- @param del? string
--- @return string, string, string
function pystring.partition(s, del)
    return c_partition(s, del)
end

--- Convert the given `s` string in a table of substrings from right
--- --
--- @param s string
--- @param delimiter string
--- @param n? integer # default is MaxInteger
--- @return table<string>
function pystring.rsplit(s, delimiter, n)
    return c_rsplit(s, delimiter, n)
end

---
--- @param s string
--- @param del? string
--- @return string, string, string
function pystring.rpartition(s, del)
    return c_rpartition(s, del)
end

local capitalize = pystring.capitalize
--- Capitalize all of words in `s`.
--- --
--- @param s string
--- @return string
function pystring.title(s)
    if #s < 1 then
        return s
    end

    local ss = c_split(s, " ")
    for i = 1, #ss do
        ss[i] = capitalize(ss[i])
    end
    return concat(ss, " ")
end

--- Capitalize line by line all the lines in `s`.
--- --
--- @param s string
--- @return string
function pystring.capwords(s)
    local lines = c_split(s, "\n")
    local rLines = {}
    for i, line in ipairs(lines) do
        local rWords = {}
        local words = c_split(line, " ")
        for j, word in ipairs(words) do
            rWords[j] = capitalize(word)
        end
        rLines[i] = concat(rWords, " ")
    end
    return concat(rLines, "\n")
end

--- Justify `s` by left with `len` copies of `ch`.
--- --
--- @param s string
--- @param len integer
--- @param ch? string # Default " "
--- @return string
function pystring.ljust(s, len, ch)
   return c_ljust(s, len, ch)
end

--- Justify `s` by right with `len` copies of `ch`.
--- --
--- @param s string
--- @param len integer
--- @param ch? string # Default " "
--- @return string
function pystring.rjust(s, len, ch)
    return c_rjust(s, len, ch)
end

--- Center `s` lines with `len` copies of `ch` in the longest line.
--- --
--- @param s string
--- @param len integer
--- @param ch? string # Default " "
--- @return string
function pystring.center(s, len, ch)
    return c_center(s, len, ch)
end

--- Justify by left with zeros.
--- --
--- @param s string
--- @param len integer
--- @return string
function pystring.zfill(s, len)
    return c_rjust(s, len, "0")
end

--- Split string line by line
--- --
--- @param s string
--- @return table<string>
function pystring.splitlines(s)
    return c_split(s, '\n')
end

--- Remove first `chars` string of `s`. 
--- --
--- @param s string
--- @param chars string
--- @return string
function pystring.lstrip(s, chars)
    return c_lstrip(s, chars)
end

--- Remove last `chars` string of `s`.
--- --
--- @param s string
--- @param chars string
--- @return string
function pystring.rstrip(s, chars)
    return c_rstrip(s, chars)
end

--- Remove last and first `chars` string of `s`, it's a consecutive
--- `lstrip` and `rstrip`.
--- --
--- @param s string
--- @param chars string
--- @return string
function pystring.strip(s, chars)
    return c_strip(s, chars)
end

--- Joins an array of *string* `strings` with `delim` between.
--- --
--- @param delim string
--- @param strings table<string>
--- @return string
function pystring.join(delim, strings)
    return c_join(delim, strings)
end

--- Check if `s1` begin with `s2`.
--- --
--- @param s1 string
--- @param s2 string
--- @return string | boolean
function pystring.startswith(s1, s2)
    return c_startswith(s1, s2)
end

--- Check if `s1` ends with `s2`.
--- --
--- @param s1 string
--- @param s2 string
--- @return string | boolean
function pystring.endswith(s1, s2)
    return c_endswith(s1, s2)
end

--- Get the first ocurrence of `s2` in `s1` beginning from `start`
--- and finishing at `stop`.
--- --
--- @param s1 string
--- @param s2 string
--- @param start? integer # Default 1
--- @param stop? integer # Default -1 --> end
--- @return integer
function pystring.find(s1, s2, start, stop)
    return c_find(s1, s2, start, stop)
end


--- Get the first ocurrence of `s2` in `s1` beginning from `start`
--- and finishing at `stop` but working with the reversed version of
--- `s1`.
--- --
--- @param s1 string
--- @param s2 string
--- @param start? integer # Default 1
--- @param stop? integer # Default -1 --> end
--- @return integer
function pystring.rfind(s1, s2, start, stop)
    return c_rfind(s1, s2, start, stop)
end

--- Get the first ocurrence of `s2` in `s1` starting at `start`
--- and finishing at `stop`.
--- --
--- @param s1 string
--- @param s2 string
--- @param start integer
--- @param stop integer
--- @return integer
function pystring.index(s1, s2, start, stop)
    local res = c_find(s1, s2, start, stop)
    if res < 0 then
        error(format("%s is  not in %s", tostring(s2), tostring(s1)))
    end
    return res
end

--- Get the index of first `s2` ocurrence in `s1` beginning from `start`
--- and ending at `stop`
--- --
--- @param s1 string
--- @param s2 string
--- @param start integer
--- @param stop integer
--- @return integer
function pystring.rindex(s1, s2, start, stop)
    local res = c_rfind(s1, s2, start, stop)
    if res < 0 then
        error(format("%s is  not in %s", tostring(s2), tostring(s1)))
    end
    return res
end

--- Count how many times the pattern appears in the target
--- string.
--- --
--- @param s string
--- @param token string
--- @param start integer
--- @param stop integer
--- @return integer
function pystring.count(s, token, start, stop)
    return c_count(s, token, start, stop)
end

--- Replaces the first n occurrences which matches with 'find' pattern
--- and substitutes them by repl.
--- --
--- @param s string
--- @param find string # Regular expression
--- @param repl string # Replacement
--- @param n integer # Number of occurrences until stop counting.
--- @return string, integer
function pystring.replace(s, find, repl, n)
    return c_replace(s, find, repl, n)
end


--- Replaces the first n occurrences which matches with 'rfind' pattern
--- and substitutes them by repl.
--- --
--- @param s string
--- @param find string # Regular expression
--- @param repl string # Replacement
--- @param n integer # Number of occurrences until stop counting.
--- @return string, integer
function pystring.rreplace(s, find, repl, n)
    return c_rreplace(s, find, repl, n)
end

--- Expand blank spaces in the string by 'tabs' times.
--- --
--- @param s string
--- @param tabs? integer # Default is 4
--- @return string, integer
function pystring.expandtabs(s, tabs)
    tabs = tabs or 4
    local repl = rep(" ", tabs)
    return gsub(s, "\t", repl)
end

--- Map format string with a table.
--- --
--- @param fmt string
--- @param t table<string>
--- @param delimiter? string
function pystring.map_format(fmt, t, delimiter)
    return c_map_format(fmt, t, delimiter)
end

--- default callback function for pystring.with, mode lines
--- --
--- @param line string
--- @return string or nil, nil will break lines loop
local function withLines(line)
    return line
end

--- default callback function for pystring.with, mode raw
--- --
--- @param content string
--- @return string
local function withRaw(content)
    return content
end

local io_open = io.open
--- Focus on the file content without worrying about the file descriptor.
--- `executor` function evals every line if `mode` is set to "line" or the full
--- file content if it is set to "raw" or `nil`.
--- --
--- @param file_name string # Name of the file
--- @param mode string # {"lines", "raw" | nil} How the file will be processed, default raw.
--- @param executor? function # Function that works with the file descriptor,
--- @param file_opt? string # File options. See `io.open`, default `r`
--- @return any
function pystring.with(file_name, mode, executor, file_opt)
    mode = mode or "raw"
    file_opt = file_opt or "r"

    if not executor then
        if mode == "raw" then
            executor = withRaw
        elseif mode == "lines" then
            executor = withLines
        else
            error(format("bad mode %s for pystring.with", mode))
        end
    end

    if match(file_opt, 'w') or match(file_opt,'a') then
        error("pystring.with doesn't work with writing mode files")
    end

    local f = io_open(file_name, file_opt)
    local r

    if f then
        if mode == 'lines' then
            r = {}
            local c = 1
            for l in f:lines() do
                local res = executor(l) -- note that r can be skipped on executor implementation
                if res then
                    r[c] = res
                    c = c + 1
                else
                    break
                end
            end
        elseif (not mode or mode == 'raw') then
            local _raw_file, err = f:read("*a")
            if not _raw_file then
                f:close()
                error(format("Problems reading %s, report: %s", file_name, tostring(err)))
            end
            r = executor(_raw_file)
        else
            f:close()
            error(format('Invalid mode = %s option',mode))
        end
    else
        error(format("Problems opening %s", tostring(file_name)))
    end
    f:close()
    return r
end

return pystring
